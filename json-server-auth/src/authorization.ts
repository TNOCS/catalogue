import * as fs from 'fs';
import {Request, Response, Express, NextFunction} from 'express';
import * as bodyParser from 'body-parser';
import * as jsonwebtoken from 'jsonwebtoken';
import * as expressjwt from 'express-jwt';

var config: IConfig = require('./config');
// Get the jwt middleware method by adding the secret to the express-jwt method.
var jwt = expressjwt({ secret: config.secret });

export interface IUser {
    email?:       string;
    displayName?: string;
    password?:    string;
    newPassword?: string;
    role?:        string;
}

export interface IConfig {
    Url: string;
    signupUrl: string;
    profileUrl: string;
    loginUrl: string;
    logoutUrl: string;
    port: number;
    secret: string;
    users: {
        [email: string]: IUser
    },
    authorizations: {
        [httpMethod: string]: {
            routes: string[],
            roles?: string[]
        }[]
    }
}

/**
 * AuthenticationService is responsible for registering the login, signup and profile URL, according to the specification in the config file.
 * - When an existing user logs in successfully, a JSON Web Token is returned, containing the user role (role) and email/identity (sub).
 * - Only admins (user who's role is admin) are allowed to create new users (signup) by specifying their email, role and display name.
 *   On successful signup, a new user is created and saved to the config file. The initial password is generated by the client and
 *   should be provided to the new user.
 * - Via a post to the signup URL, setting password and newPassword in the body of the message, the user can change his password.
 * - Passwords should not be stored in clear text, but hashed.
 */
export class AuthenticationService {
    static registerRoutes(server: Express) {
        if (!config.authorizations) config.authorizations = {};
        // Authorize the authentication URLs: since we authenticate them here, we can let them pass through in the authorize function. 
        if (!config.authorizations.hasOwnProperty('PUT')) config.authorizations['PUT'] = [];
        config.authorizations['PUT'].push({ routes: [config.profileUrl] });
        if (!config.authorizations.hasOwnProperty('POST')) config.authorizations['POST'] = [];
        config.authorizations['POST'].push({ routes: [config.loginUrl, config.signupUrl] });

        // parse body, either in JSON or as application/x-www-form-urlencoded
        server.use(bodyParser.json());
        server.use(bodyParser.urlencoded({ extended: false }))

        // Login
        server.post(config.loginUrl, (req: Request, res: Response) => {
            let body: IUser = req.body;

            if (!body
                || !body.email
                || !body.password
                || !config.users.hasOwnProperty(body.email)
                || config.users[body.email].password !== body.password) {
                // Perhaps we just want to refresh our existing token
                jwt(req, res, () => {
                    if (!req.user || !req.user.sub) res.sendStatus(403);
                    else this.sendToken(res, req.user.sub);
                });
            } else {
                // Authenticated: generate a JSON web token and return it
                this.sendToken(res, body.email);
            }
        });

        // signup
        server.post(config.signupUrl, jwt, function (req, res) {
            if (req.user.role !== 'admin') return res.send(401);
            let body: IUser = req.body;
            if (!body.email || !body.password || !body.role || !body.displayName) {
                res.sendStatus(403); // equivalent to res.status(403).send('Forbidden')
            } else {
                config.users[body.email] = {
                    displayName: body.displayName,
                    password: body.password,
                    role: body.role
                };
                AuthenticationService.saveConfig(res);
            }
        });

        // profile
        server.get(config.profileUrl, jwt, (req: Request, res: Response) => {
            if (!config.users.hasOwnProperty(req.user.sub)) return res.sendStatus(403); // equivalent to res.status(403).send('Forbidden')
            // console.log(`User profile found: ${JSON.stringify(req.user)}`);
            let user = config.users[req.user.sub];
            res.json({
                user: {
                    displayName: user.displayName,
                    email: req.user.sub,
                    role: user.role
                }
            });
        });

        // update password and/or displayName
        server.put(config.profileUrl, jwt, (req: Request, res: Response) => {
            if (!config.users.hasOwnProperty(req.user.sub)) return res.sendStatus(403); // equivalent to res.status(403).send('Forbidden')
            let body: IUser = req.body;
            let user = config.users[req.user.sub];
            // Update password?
            if (body.newPassword && body.password && body.password === user.password) user.password = body.newPassword;
            if (body.displayName) user.displayName = body.displayName;
            AuthenticationService.saveConfig(res);
        });
    }

    private static sendToken(res: Response, sub: string) {
        let user = config.users[sub];
        if (!user) {
            res.sendStatus(403);
            return;
        }
        let token = jsonwebtoken.sign({
            role: user.role,
            displayName: user.displayName,
        }, config.secret, {
                // expressed in seconds or a string describing a time span rauchg/ms. Eg: 60, "2 days", "10h", "7d"
                expiresIn: '7 days',
                subject: sub
            });
        console.log('TOKEN: ' + token);
        res.json({
            token: token,
            refresh_token: token,
            user: {
                displayName: user.displayName,
                email: user.email,
                role: user.role
            }
        });
    }

    private static saveConfig(res: Response) {
        fs.writeFile('config.json', JSON.stringify(config, null, 4), (err) => {
            if (err) {
                console.error(err.message);
                res && res.sendStatus(500); // equivalent to res.status(500).send('Internal Server Error')
            } else {
                res && res.sendStatus(200); // equivalent to res.status(200).send('OK')
            }
        })
    }
}

function isSubPathOf(path: string, req: Request) {
    return req.originalUrl.indexOf(path) >= 0;
}

/** 
 * Authorization service: intercept all PUT, POST, GET and DELETE requests. 
 * Only pass through those that you allow, based on the req.user.role as specified by the JWT.
 * 
 * NOTE: The config URLs (profileUrl, signupUrl, loginUrl) are already protected.
 */
export function authorize(req: Request, res: Response, next: Function) {
    if (!config.authorizations.hasOwnProperty(req.method)) return res.sendStatus(403);
    var routes = config.authorizations[req.method];
    var url = req.originalUrl;
    for (var route of routes) {
        // does the route match?
        let routeFound = false;
        route.routes.some(r => {
            if (url.indexOf(r) < 0) return false;
            routeFound = true;
            return true;
        })
        if (!routeFound) continue;
        // route found, are there roles specified which we need to authenticate
        if (!route.roles) return next();
        // authentication required
        jwt(req, res, (err?) => {
            if (err) return res.sendStatus(403);
            if (route.roles.indexOf(req.user.role) >= 0) return next();
            return res.sendStatus(403);
        });
        return;
    }
    return res.sendStatus(403);
}

// https://jsfiddle.net/Guffa/DDn6W/
// function randomPassword(length) {
//     var chars = "abcdefghijklmnopqrstuvwxyz!@#$%^&*()-+<>ABCDEFGHIJKLMNOP1234567890";
//     var pass = "";
//     for (var x = 0; x < length; x++) {
//         var i = Math.floor(Math.random() * chars.length);
//         pass += chars.charAt(i);
//     }
//     return pass;
// }
